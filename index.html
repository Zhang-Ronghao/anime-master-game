<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>åŠ¨æ¼«é«˜æ‰‹ Â· ä¸€çœ¼é¡¶é’ˆ</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: 'Microsoft YaHei', Arial, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .container {
      max-width: 1400px;
      width: 100%;
      background: white;
      border-radius: 20px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      padding: 30px;
    }

    .title-bar { position: relative; margin-bottom: 20px; }

    h1 {
      text-align: center;
      color: #667eea;
      margin-bottom: 0;
      font-size: 2.5em;
      line-height: 1.2;
    }

    .top-left-btn {
      position: absolute; left: 0; top: 0;
      padding: 10px 14px;
      font-size: 0.95em;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s;
      font-weight: bold;
      box-shadow: 0 3px 8px rgba(0,0,0,0.15);
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      color: white;
      white-space: nowrap;
    }
    .top-left-btn:hover { transform: translateY(-1px); box-shadow: 0 4px 10px rgba(0,0,0,0.22); }
    .top-left-btn:active { transform: translateY(0); }

    body.player-locked .top-left-btn { display: none !important; }

    .top-github-btn {
      position: absolute;
      right: 140px;
      top: 0;
      padding: 10px 14px;
      font-size: 0.95em;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s;
      font-weight: bold;
      box-shadow: 0 3px 8px rgba(0,0,0,0.15);
      background: linear-gradient(135deg, #111827 0%, #374151 100%);
      color: white;
      white-space: nowrap;
    }

    .top-github-btn:hover { transform: translateY(-1px); box-shadow: 0 4px 10px rgba(0,0,0,0.22); }
    .top-github-btn:active { transform: translateY(0); }

    body.player-locked .top-github-btn { display: none !important; }

    @media (max-width: 968px) {
      .top-github-btn { position: static; width: 100%; margin-top: 10px; }
    }

    .top-reset-btn {
      position: absolute; right: 0; top: 0;
      padding: 10px 14px;
      font-size: 0.95em;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s;
      font-weight: bold;
      box-shadow: 0 3px 8px rgba(0,0,0,0.15);
      background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);
      color: white;
      white-space: nowrap;
    }
    .top-reset-btn:hover { transform: translateY(-1px); box-shadow: 0 4px 10px rgba(0,0,0,0.22); }
    .top-reset-btn:active { transform: translateY(0); }

    body.player-locked .top-reset-btn { display: none !important; }

    .role-badge {
      display: inline-block;
      margin-left: 10px;
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 14px;
      vertical-align: middle;
      background: #eef2ff;
      color: #4338ca;
      border: 1px solid #c7d2fe;
    }

    .status-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: #f8f9fa;
      padding: 15px 20px;
      border-radius: 10px;
      margin-bottom: 20px;
      gap: 10px;
      flex-wrap: wrap;
    }
    .status-item { font-size: 1.1em; color: #333; }
    .status-item strong { color: #667eea; }

    .scoreboard {
      background: linear-gradient(135deg, #fff9e6 0%, #ffe6cc 100%);
      padding: 20px;
      border-radius: 15px;
      margin-bottom: 20px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }

    .scoreboard-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 15px;
    }
    .scoreboard h2 {
      color: #ff9800;
      text-align: center;
      font-size: 1.5em;
      margin: 0;
      flex: 1;
    }
    .scoreboard-actions {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      align-items: center;
      flex: 0 0 auto;
    }

    .btn-mini {
      padding: 10px 14px;
      font-size: 0.95em;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.2s;
      font-weight: bold;
      box-shadow: 0 3px 8px rgba(0,0,0,0.15);
      white-space: nowrap;
    }
    .btn-mini:hover { transform: translateY(-1px); box-shadow: 0 4px 10px rgba(0,0,0,0.22); }
    .btn-mini:active { transform: translateY(0); }
    .btn-mini-danger { background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%); color: white; }

    .players-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
    }
    .player-card {
      background: white;
      padding: 15px;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .player-info { flex: 1; }
    .player-name { font-size: 1.2em; font-weight: bold; color: #333; margin-bottom: 5px; }
    .player-score { font-size: 1.8em; color: #ff9800; font-weight: bold; }

    .score-buttons { display: flex; gap: 5px; flex-direction: column; }
    .score-btn {
      width: 35px;
      height: 35px;
      border: none;
      border-radius: 5px;
      font-size: 1.2em;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
    }
    .score-btn.plus { background: #4CAF50; color: white; }
    .score-btn.plus:hover { background: #45a049; transform: scale(1.1); }
    .score-btn.minus { background: #f44336; color: white; }
    .score-btn.minus:hover { background: #d32f2f; transform: scale(1.1); }

    .game-area {
      display: flex;
      gap: 30px;
      margin-bottom: 20px;
      align-items: flex-start;
    }

    .image-container {
      flex: 1;
      position: relative;
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      min-height: 220px;
    }

    .image-wrapper { position: relative; display: inline-block; width: 100%; }

    #gameImage { width: 100%; height: auto; display: block; }

    #playerCanvas { width: 100%; height: auto; display: none; }
    body.player-locked #playerCanvas { display: block; }
    body.player-locked #gameImage { display: none !important; }

    .loading {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 16px;
      color: #666;
      font-size: 1.2em;
      z-index: 30;
      pointer-events: none;
      background: transparent;
    }
    .loading-inner { max-width: 560px; }
    .loading-hint {
      margin-top: 10px;
      font-size: 0.95em;
      color: #8b5e00;
      line-height: 1.5;
    }

    .grid-overlay {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      display: grid;
      grid-template-columns: repeat(9, 1fr);
      grid-template-rows: repeat(5, 1fr);
      pointer-events: none;
      z-index: 10;
    }

    .curtain {
      position: absolute;
      inset: 0;
      background: #000;
      z-index: 9;
      display: none;
    }

    .grid-cell {
      border: none;
      outline: 1px solid rgba(255, 255, 255, 0.3);
      outline-offset: -1px;
      cursor: pointer;
      pointer-events: all;
      transition: all 0.25s;
      background: transparent;
    }
    .no-transition .grid-cell { transition: none !important; }

    .grid-cell.selectable:hover { background: rgba(102, 126, 234, 0.3); }
    .grid-cell.selected { background: rgba(255, 193, 7, 0.6); border: 2px solid #ffc107; }

    .grid-cell.revealed { background: transparent; border: none; box-shadow: none; }
    .grid-cell.revealed-hint { background: rgba(76, 175, 80, 0.55); }
    .grid-cell.covered { background: rgba(0, 0, 0, 1); }

    body.player-locked .grid-cell {
      pointer-events: none !important;
      cursor: default !important;
      background: transparent !important;
    }

    .control-panel {
      flex: 0 0 320px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .btn {
      padding: 14px 22px;
      font-size: 1.05em;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.2s;
      font-weight: bold;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
      white-space: nowrap;
    }
    .btn:hover { transform: translateY(-2px); box-shadow: 0 6px 15px rgba(0, 0, 0, 0.3); }
    .btn:active { transform: translateY(0); }
    .btn-primary { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; }
    .btn-success { background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%); color: white; }
    .btn-warning { background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%); color: white; }
    .btn-danger  { background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%); color: white; }
    .btn-info    { background: linear-gradient(135deg, #2196f3 0%, #1976d2 100%); color: white; }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }

    .info-box {
      background: #e3f2fd;
      padding: 14px;
      border-radius: 10px;
      border-left: 4px solid #2196f3;
    }
    .info-box p { color: #555; line-height: 1.6; }
    .info-box a { color: #1976d2; font-weight: 700; text-decoration: underline; }

    .selection-count {
      background: #fff3cd;
      padding: 10px;
      border-radius: 8px;
      text-align: center;
      font-weight: bold;
      color: #856404;
    }

    .config-modal {
      display: none;
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }
    .config-modal.active { display: flex; }

    .config-content {
      background: white;
      padding: 30px;
      border-radius: 15px;
      max-width: 860px;
      width: 94%;
      max-height: 80vh;
      overflow-y: auto;
    }

    .config-content h2 { color: #667eea; margin-bottom: 20px; }

    .config-content textarea {
      width: 100%;
      min-height: 300px;
      padding: 15px;
      border: 2px solid #ddd;
      border-radius: 8px;
      font-family: monospace;
      font-size: 14px;
      margin-bottom: 15px;
    }

    .config-buttons {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 10px;
      flex-wrap: wrap;
    }
    .config-buttons .btn { min-width: 160px; padding: 12px 18px; font-size: 1.0em; }

    .library-row {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      margin: 6px 0 12px;
    }
    .library-row .btn { min-width: 160px; padding: 12px 18px; font-size: 1.0em; }

    .preset-select {
      min-width: 260px;
      height: 46px;
      font-weight: 700;
      border-radius: 10px;
      border: 2px solid #ddd;
      padding: 8px 12px;
    }
    .preset-hidden { display: none; }

    .player-setup { margin-bottom: 20px; }
    .player-input {
      width: 100%;
      padding: 10px;
      margin-bottom: 10px;
      border: 2px solid #ddd;
      border-radius: 8px;
      font-size: 1em;
    }

    .player-count-selector { display: flex; gap: 10px; margin-bottom: 15px; flex-wrap: wrap; }

    .count-btn {
      padding: 10px 20px;
      border: 2px solid #667eea;
      background: white;
      border-radius: 8px;
      cursor: pointer;
      font-size: 1em;
      font-weight: bold;
      color: #667eea;
      transition: all 0.2s;
    }
    .count-btn:hover { background: #667eea; color: white; }
    .count-btn.active { background: #667eea; color: white; }

    .player-names-input { display: none; }
    .player-names-input.active { display: block; }

    body.player-locked .control-panel,
    body.player-locked .config-modal { display: none !important; }

    body.player-locked .grid-overlay { pointer-events: none !important; }
    body.player-locked .score-buttons { display: none !important; }

    @media (max-width: 968px) {
      .game-area { flex-direction: column; }
      .control-panel { flex: 1; }
      .scoreboard-header { flex-direction: column; }
      .scoreboard-actions { width: 100%; justify-content: center; }
      .top-reset-btn, .top-left-btn { position: static; width: 100%; margin-top: 10px; }
      .title-bar { display: flex; flex-direction: column; gap: 8px; }

      .library-row { flex-direction: column; align-items: stretch; }
      .library-row .btn { width: 100%; min-width: 0; }
      .preset-select { width: 100%; min-width: 0; }

      .config-buttons .btn { width: 100%; min-width: 0; }
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="title-bar">
      <button class="top-left-btn" id="shareLibraryBtn" onclick="openShareLibrary()">åˆ†äº«æ‚¨çš„é¢˜åº“</button>
      <h1>ğŸ® åŠ¨æ¼«é«˜æ‰‹ Â· ä¸€çœ¼é¡¶é’ˆ <span class="role-badge" id="roleBadge">role</span></h1>
      <button class="top-github-btn" id="githubBtn" onclick="openGithub()">GitHub</button>
      <button class="top-reset-btn" id="resetAllBtnTop" onclick="resetAll()">â™»ï¸ ä¸€é”®é‡ç½®</button>
    </div>

    <div class="scoreboard" id="scoreboard" style="display:none;">
      <div class="scoreboard-header">
        <h2>ğŸ† ç©å®¶è®¡åˆ†æ¿</h2>
        <div class="scoreboard-actions" id="scoreboardActions" style="display:none;">
          <button class="btn-mini btn-mini-danger" onclick="clearAllScores()">ğŸ§¹ æ¸…ç©ºåˆ†æ•°</button>
        </div>
      </div>
      <div class="players-grid" id="playersGrid"></div>
    </div>

    <div class="status-bar">
      <div class="status-item"><strong>å½“å‰å›¾ç‰‡ï¼š</strong> <span id="currentImage">0</span> / <span id="totalImages">0</span></div>
      <div class="status-item"><strong>å½“å‰è½®æ¬¡ï¼š</strong> <span id="currentRound">0</span></div>
      <div class="status-item"><strong>å·²å±•ç¤ºæ–¹å—ï¼š</strong> <span id="revealedCount">0</span> / 45</div>
    </div>

    <div class="game-area">
      <div class="image-container">
        <div class="image-wrapper" id="imageWrapper">
          <img id="gameImage" src="" alt="æ¸¸æˆå›¾ç‰‡" style="display:none;">
          <canvas id="playerCanvas"></canvas>

          <div class="curtain" id="curtain"></div>
          <div class="grid-overlay" id="gridOverlay"></div>
        </div>

        <div class="loading" id="loadingText" style="display:block;">
          <div class="loading-inner">
            <div id="loadingMain">è¯·å…ˆè®¾ç½®ç©å®¶å’Œå›¾ç‰‡</div>
            <div class="loading-hint" id="loadingHint" style="display:none;"></div>
          </div>
        </div>
      </div>

      <div class="control-panel" id="controlPanel">
        <button class="btn btn-info" id="helpBtn" onclick="openHelp()">â“ å¸®åŠ©</button>
        <button class="btn btn-info" id="openPlayerBtn" onclick="openPlayerScreen()">ğŸ–¥ï¸ æ‰“å¼€ç©å®¶æ˜¾ç¤ºå±</button>
        <button class="btn btn-info" id="playerSetupBtn" onclick="openPlayerSetup()">ğŸ‘¥ è®¾ç½®ç©å®¶</button>
        <button class="btn btn-info" id="configBtn" onclick="openConfig()">âš™ï¸ é…ç½®å›¾ç‰‡é“¾æ¥</button>

        <div class="selection-count" id="selectionCount">å·²é€‰æ‹©: 0 ä¸ªæ–¹å—</div>

        <button class="btn btn-success" id="showFullBtn" onclick="showFullImage()" disabled>ğŸ§© é€‰æ‹©å±•ç¤ºåŒºå—</button>
        <button class="btn btn-primary" id="confirmSelectionBtn" onclick="confirmSelection()" disabled>âœ… ç¡®è®¤é€‰æ‹©å¹¶å±•ç¤º</button>
        <button class="btn btn-warning" id="revealAnswerBtn" onclick="revealAnswerToAll()" disabled>ğŸ–¼ï¸ å‘ç©å®¶å±•ç¤ºå®Œæ•´å›¾ç‰‡ï¼ˆå…¬å¸ƒç­”æ¡ˆï¼‰</button>
        <button class="btn btn-danger" id="nextImageBtn" onclick="nextImage()" disabled>â­ï¸ ä¸‹ä¸€å¼ å›¾ç‰‡</button>
      </div>
    </div>
  </div>

  <!-- âœ… å¸®åŠ©å¼¹çª— -->
  <div class="config-modal" id="helpModal">
    <div class="config-content">
      <h2>â“ å¸®åŠ©</h2>
      <div class="info-box" style="margin-bottom: 15px;">
        <p id="instructionText">
          <b>ã€æ¸¸æˆå‰é…ç½®ã€‘</b><br>
          ç‚¹å‡»ã€Œæ‰“å¼€ç©å®¶æ˜¾ç¤ºå±ã€â†’ å°†ç©å®¶çª—å£æŠ•å±ç»™ç©å®¶ï¼ˆå¦‚è…¾è®¯ä¼šè®®å…±äº«ï¼‰â†’ ç‚¹å‡»ã€Œè®¾ç½®ç©å®¶ã€â†’ ç‚¹å‡»ã€Œé…ç½®å›¾ç‰‡é“¾æ¥ã€<br><br>

          <b>ã€æ¸¸æˆè¿›è¡Œä¸­ã€‘</b><br>
          å¯å¤šè½®æ‰§è¡Œï¼šç‚¹å‡»ã€Œé€‰æ‹©å±•ç¤ºåŒºå—ã€â†’ é€‰æ‹©ä»»æ„æ•°é‡åŒºå— â†’ ç‚¹å‡»ã€Œç¡®è®¤é€‰æ‹©å¹¶å±•ç¤ºã€ï¼ˆç©å®¶æŠ¢ç­”ï¼‰<br>
          æ¯å¼ å›¾ç‰‡å¯é‡å¤å¤šè½®ï¼Œç›´åˆ°æœ‰ç©å®¶ç­”å¯¹ <br><br>

          âš ï¸ æ³¨æ„ï¼šç©å®¶å±ä¸è¦æœ€å°åŒ–ï¼Œä¸»æŒäººå±ä¸è¦æœ€å¤§åŒ–å®Œå…¨é®æŒ¡ç©å®¶å±ï¼Œå¦åˆ™ç”»é¢å¯èƒ½æ— æ³•å®æ—¶åˆ·æ–°ã€‚<br><br>

          <a href="https://github.com/Davy-Chendy/anime-master-game" target="_blank" rel="noopener noreferrer">ğŸ“– è¯¦ç»†è¯´æ˜ï¼ˆå¯æ„å»ºè‡ªå·±çš„é¢˜åº“ï¼‰</a>
        </p>
      </div>
      <div class="config-buttons">
        <button class="btn btn-warning" onclick="closeHelp()">å…³é—­</button>
      </div>
    </div>
  </div>

  <!-- ç©å®¶è®¾ç½®æ¨¡æ€æ¡† -->
  <div class="config-modal" id="playerSetupModal">
    <div class="config-content">
      <h2>ğŸ‘¥ è®¾ç½®ç©å®¶</h2>
      <div class="player-setup">
        <p style="color: #666; margin-bottom: 15px;">è¯·é€‰æ‹©ç©å®¶äººæ•°ï¼š</p>
        <div class="player-count-selector" id="playerCountSelector">
          <button class="count-btn" onclick="selectPlayerCount(2)">2äºº</button>
          <button class="count-btn" onclick="selectPlayerCount(3)">3äºº</button>
          <button class="count-btn" onclick="selectPlayerCount(4)">4äºº</button>
          <button class="count-btn" onclick="selectPlayerCount(5)">5äºº</button>
          <button class="count-btn" onclick="selectPlayerCount(6)">6äºº</button>
          <button class="count-btn" onclick="selectPlayerCount(7)">7äºº</button>
          <button class="count-btn" onclick="selectPlayerCount(8)">8äºº</button>
        </div>

        <div class="player-names-input" id="playerNamesInput">
          <p style="color: #666; margin-bottom: 10px;">è¯·è¾“å…¥ç©å®¶åå­—ï¼š</p>
          <div id="nameInputs"></div>
        </div>
      </div>
      <div class="config-buttons">
        <button class="btn btn-primary" onclick="savePlayerSetup()">ğŸ’¾ ä¿å­˜ç©å®¶è®¾ç½®</button>
        <button class="btn btn-warning" onclick="closePlayerSetup()">âŒ å–æ¶ˆ</button>
      </div>
    </div>
  </div>

  <!-- å›¾ç‰‡é…ç½®æ¨¡æ€æ¡† -->
  <div class="config-modal" id="configModal">
    <div class="config-content" style="position: relative;">
      <button class="btn"
        style="
          position:absolute; top: 16px; right: 20px;
          background: linear-gradient(135deg, #10b981 0%, #059669 100%);
          color: white; min-width: 160px; padding: 12px 18px; font-size: 1.0em;
          font-weight: bold; border-radius: 10px; box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        "
        onclick="openShareLibrary()" type="button">
        åˆ†äº«æ‚¨çš„é¢˜åº“
      </button>

      <h2>âš™ï¸ é…ç½®å›¾ç‰‡é“¾æ¥</h2>

      <a href="https://github.com/Davy-Chendy/anime-master-game"
        target="_blank"
        rel="noopener noreferrer"
        style="display: inline-block; margin: 6px 0 12px; color:#1a73e8; text-decoration: none;">
        ğŸ“– å¦‚ä½•æ„å»ºè‡ªå·±çš„é¢˜åº“
      </a>

      <p style="color: #666; margin-bottom: 10px;">
        æ¯è¡Œä¸€ä¸ªå›¾ç‰‡URLï¼Œæ”¯æŒä»»ä½•å¯è®¿é—®çš„åœ¨çº¿å›¾ç‰‡é“¾æ¥<br>
        ç¤ºä¾‹ï¼šhttps://example.com/pic1.jpg
      </p>

      <div class="library-row">
        <button class="btn btn-info" type="button" onclick="openSharedLibrary()">æµè§ˆå…±äº«é¢˜åº“</button>
        <button class="btn btn-info" type="button" onclick="togglePresetDropdown()">ä½œè€…é¢„è®¾é¢˜åº“</button>
        <select id="presetSelect" class="preset-select preset-hidden" onchange="applySelectedPreset()">
          <option value="" selected disabled>è¯·é€‰æ‹©ä¸€ä¸ªé¢„è®¾é¢˜åº“...</option>
        </select>
      </div>

      <textarea id="imageUrlsInput"
        placeholder="è¯·è¾“å…¥å›¾ç‰‡é“¾æ¥ï¼Œæ¯è¡Œä¸€ä¸ª&#10;https://example.com/pic1.jpg&#10;https://example.com/pic2.jpg&#10;..."></textarea>

      <div class="config-buttons">
        <button class="btn btn-primary" onclick="saveConfig()">ğŸ’¾ ä¿å­˜é…ç½®</button>
        <button class="btn btn-warning" onclick="closeConfig()">âŒ å–æ¶ˆ</button>
      </div>
    </div>
  </div>

  <div class="config-modal" id="saveLoadingModal">
    <div class="config-content" style="max-width:520px;">
      <h2 id="saveLoadingTitle" style="margin-bottom:12px;">â³ æ­£åœ¨åŠ è½½å›¾ç‰‡...</h2>
      <div class="info-box">
        <p id="saveLoadingText" style="margin:0; line-height:1.6;">æ­£åœ¨åŠ è½½ç¬¬ 1 å¼ å›¾ç‰‡ï¼Œè¯·ç¨å€™â€¦</p>
      </div>
      <div class="config-buttons" style="margin-top:14px;">
        <button class="btn btn-warning" type="button" onclick="closeSaveLoadingModal()" disabled id="saveLoadingCloseBtn">
          è¯·ç¨å€™...
        </button>
      </div>
    </div>
  </div>

  <script>
    const params = new URLSearchParams(location.search);
    const ROLE = (params.get('role') || 'host').toLowerCase();
    const IS_HOST = ROLE !== 'player';

    const CHANNEL_NAME = 'anime-game-sync-v4';
    const channel = new BroadcastChannel(CHANNEL_NAME);

    let currentImageIndex = 0;
    let currentRound = 0;
    let selectedCells = [];
    let revealedCells = new Set();
    let isFullImageMode = false;
    let imageUrls = [];
    let players = [];

    let imageLoadToken = 0;
    let loadingWarnTimer = null;

    let answerRevealed = false;

    const ROWS = 5, COLS = 9;
    const TOTAL_CELLS = ROWS * COLS;

    // ===== ç©å®¶å± Canvas ç™½åå•ç»˜åˆ¶ =====
    const playerImg = new Image();
    playerImg.decoding = 'async';
    let playerImgReady = false;
    let playerCurrentUrl = '';

    function getCellRectByIndex(i, W, H) {
      const r = Math.floor(i / COLS);
      const c = i % COLS;
      const sw = W / COLS;
      const sh = H / ROWS;
      const sx = c * sw;
      const sy = r * sh;
      return { r, c, sx, sy, sw, sh };
    }

    function ensurePlayerCanvasSized() {
      const canvas = document.getElementById('playerCanvas');
      const wrapper = document.getElementById('imageWrapper');
      if (!canvas || !wrapper) return;

      const displayW = Math.max(1, Math.floor(wrapper.clientWidth || 1));

      const natW = playerImgReady ? (playerImg.naturalWidth || 1) : 16;
      const natH = playerImgReady ? (playerImg.naturalHeight || 1) : 9;
      const displayH = Math.max(1, Math.floor(displayW * (natH / natW)));

      const dpr = window.devicePixelRatio || 1;
      canvas.width = Math.max(1, Math.floor(displayW * dpr));
      canvas.height = Math.max(1, Math.floor(displayH * dpr));

      canvas.style.width = displayW + 'px';
      canvas.style.height = displayH + 'px';

      syncGridOverlayToTarget();
    }

    function syncGridOverlayToTarget() {
      const overlay = document.getElementById('gridOverlay');
      const canvas = document.getElementById('playerCanvas');
      const img = document.getElementById('gameImage');
      if (!overlay) return;

      if (!IS_HOST && canvas) {
        const rect = canvas.getBoundingClientRect();
        overlay.style.width = rect.width + 'px';
        overlay.style.height = rect.height + 'px';
        return;
      }
      if (IS_HOST && img) {
        overlay.style.width = img.offsetWidth + 'px';
        overlay.style.height = img.offsetHeight + 'px';
      }
    }

    function drawPlayerCanvasFromState() {
      if (IS_HOST) return;
      const canvas = document.getElementById('playerCanvas');
      if (!canvas) return;

      ensurePlayerCanvasSized();

      const ctx = canvas.getContext('2d');
      if (!ctx) return;

      const CW = canvas.width;
      const CH = canvas.height;

      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, CW, CH);
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, CW, CH);

      if (!playerImgReady || !playerImg.naturalWidth || !playerImg.naturalHeight) return;

      const natW = playerImg.naturalWidth;
      const natH = playerImg.naturalHeight;

      const cellDW = CW / COLS;
      const cellDH = CH / ROWS;

      const drawOneCell = (idx) => {
        const { r, c, sx, sy, sw, sh } = getCellRectByIndex(idx, natW, natH);
        const dx = c * cellDW;
        const dy = r * cellDH;
        ctx.drawImage(playerImg, sx, sy, sw, sh, dx, dy, cellDW, cellDH);
      };

      if (answerRevealed) {
        ctx.drawImage(playerImg, 0, 0, natW, natH, 0, 0, CW, CH);
      } else {
        for (const idx of revealedCells) {
          if (typeof idx !== 'number') continue;
          if (idx < 0 || idx >= TOTAL_CELLS) continue;
          drawOneCell(idx);
        }
      }
    }

    // ====== ä½œè€…é¢„è®¾é¢˜åº“ï¼ˆJSONï¼‰======
    let presetBank = null;
    let presetKeys = [];
    let presetLoadedOnce = false;

    async function loadPresetBankIfNeeded() {
      if (presetLoadedOnce && presetBank) return;

      const select = document.getElementById('presetSelect');

      try {
        const res = await fetch('./examples.json', { cache: 'no-store' });
        if (!res.ok) throw new Error('HTTP ' + res.status);

        const data = await res.json();
        if (!data || typeof data !== 'object') throw new Error('examples.json æ ¼å¼ä¸æ˜¯å¯¹è±¡');

        presetBank = data;
        presetKeys = Object.keys(presetBank).filter(k => Array.isArray(presetBank[k]));

        if (presetKeys.length === 0) throw new Error('examples.json ä¸­æ²¡æœ‰å¯ç”¨é¢˜åº“æ•°ç»„ï¼ˆvalue å¿…é¡»æ˜¯æ•°ç»„ï¼‰');

        if (select) {
          select.innerHTML = `<option value="" selected disabled>è¯·é€‰æ‹©ä¸€ä¸ªé¢„è®¾é¢˜åº“...</option>`;
          presetKeys.forEach(k => {
            const opt = document.createElement('option');
            opt.value = k;
            opt.textContent = `${k}ï¼ˆ${presetBank[k].length} å¼ ï¼‰`;
            select.appendChild(opt);
          });
        }

        presetLoadedOnce = true;
      } catch (e) {
        console.error(e);
        presetBank = null;
        presetKeys = [];
        presetLoadedOnce = false;
        alert(
          'è¯»å– examples.json å¤±è´¥ã€‚\n' +
          'è¯·ç¡®è®¤ examples.json ä¸ index.html åœ¨åŒä¸€ç›®å½•ï¼Œå¹¶é€šè¿‡ http(s) æ–¹å¼è¿è¡Œã€‚\n\n' +
          'é”™è¯¯ä¿¡æ¯ï¼š' + (e && e.message ? e.message : String(e))
        );
      }
    }

    async function togglePresetDropdown() {
      if (!IS_HOST) return;
      const select = document.getElementById('presetSelect');
      if (!select) return;

      await loadPresetBankIfNeeded();
      if (!presetBank) return;

      select.classList.remove('preset-hidden');
      select.value = "";
      setTimeout(() => { try { select.focus(); } catch (e) {} }, 0);
    }

    function applySelectedPreset() {
      if (!IS_HOST) return;
      const select = document.getElementById('presetSelect');
      const textarea = document.getElementById('imageUrlsInput');
      if (!select || !textarea) return;

      const key = select.value;
      if (!key || !presetBank || !Array.isArray(presetBank[key])) return;

      textarea.value = '';

      const urls = presetBank[key].map(s => String(s).trim()).filter(s => s.length > 0);
      if (urls.length === 0) { alert('è¯¥é¢„è®¾é¢˜åº“ä¸ºç©ºã€‚'); return; }

      textarea.value = urls.join('\n');

      select.value = "";
      select.classList.add('preset-hidden');

      alert(`å·²è½½å…¥é¢„è®¾é¢˜åº“ï¼š${key}ï¼ˆ${urls.length} å¼ ï¼‰\n\nè¯·ç‚¹å‡»ã€Œä¿å­˜é…ç½®ã€ä½¿å…¶ç”Ÿæ•ˆã€‚`);
    }

    // ========= é¢„åŠ è½½ï¼šçœŸÂ·æ»‘åŠ¨çª—å£ï¼ˆåª Host é¢„åŠ è½½ + å½“å‰å›¾ç»å¯¹ä¼˜å…ˆï¼‰=========
    const PRELOAD_LOOKAHEAD = 6;     // âœ… åªé¢„åŠ è½½æœªæ¥ N å¼ 
    const PRELOAD_CONCURRENCY = 1;   // âœ… å¹¶å‘ 1ï¼ˆæœ€ç¨³ï¼‰

    const preloadCache = new Map();  // url -> { status, ts }
    let preloadQueue = [];
    let preloadInFlight = 0;
    let preloadDesired = new Set();
    let preloadPaused = false;

    function setPreloadPaused(paused) {
      preloadPaused = !!paused;
      if (!preloadPaused) pumpPreloadQueue();
    }

    function computeWindowUrls(index) {
      if (!Array.isArray(imageUrls) || imageUrls.length <= 1) return [];
      const L = imageUrls.length;
      const n = Math.min(PRELOAD_LOOKAHEAD, L - 1);
      const out = [];
      for (let k = 1; k <= n; k++) {
        const i = (index + k) % L;
        const url = imageUrls[i];
        if (url) out.push(url);
      }
      return out;
    }

    function updatePreloadWindow(index) {
      if (!IS_HOST) return; // âœ… Player ä¸é¢„åŠ è½½
      const windowUrls = computeWindowUrls(index);
      const desired = new Set(windowUrls);
      preloadDesired = desired;

      // queue åªä¿ç•™çª—å£å†…
      preloadQueue = preloadQueue.filter(u => preloadDesired.has(u));

      // cache åªä¿ç•™çª—å£å†… + loadingï¼ˆçª—å£å¤–ä¸”é loading çš„ç›´æ¥æ¸…æ‰ï¼Œé¿å…æ— é™å¢é•¿ï¼‰
      for (const [url, entry] of preloadCache.entries()) {
        if (!preloadDesired.has(url) && entry && entry.status !== 'loading') {
          preloadCache.delete(url);
        }
      }

      // æŒ‰çª—å£é¡ºåºè¡¥é½ queue
      for (const url of windowUrls) {
        const st = preloadCache.get(url)?.status;
        if (st === 'loaded' || st === 'loading') continue;

        if (!preloadQueue.includes(url)) preloadQueue.push(url);
        preloadCache.set(url, { status: 'queued', ts: Date.now() });
      }

      pumpPreloadQueue();
    }

    function pumpPreloadQueue() {
      if (!IS_HOST) return;
      if (preloadPaused) return; // âœ… å½“å‰å›¾åŠ è½½æœŸé—´ä¸å¯åŠ¨é¢„åŠ è½½ï¼ˆç»å¯¹ä¼˜å…ˆï¼‰
      while (preloadInFlight < PRELOAD_CONCURRENCY && preloadQueue.length > 0) {
        const url = preloadQueue.shift();
        if (!url) continue;

        if (!preloadDesired.has(url)) {
          preloadCache.delete(url);
          continue;
        }

        const entry = preloadCache.get(url);
        if (!entry || entry.status !== 'queued') continue;

        entry.status = 'loading';
        entry.ts = Date.now();
        preloadInFlight++;

        const img = new Image();
        img.decoding = 'async';
        try { img.referrerPolicy = 'no-referrer'; } catch (e) {}

        img.onload = () => {
          preloadInFlight--;
          const e = preloadCache.get(url);
          if (e) {
            if (!preloadDesired.has(url)) preloadCache.delete(url);
            else { e.status = 'loaded'; e.ts = Date.now(); }
          }
          pumpPreloadQueue();
        };

        img.onerror = () => {
          preloadInFlight--;
          const e = preloadCache.get(url);
          if (e) {
            if (!preloadDesired.has(url)) preloadCache.delete(url);
            else { e.status = 'error'; e.ts = Date.now(); }
          }
          pumpPreloadQueue();
        };

        img.src = url;
      }
    }

    function resetPreloadAll() {
      preloadCache.clear();
      preloadQueue = [];
      preloadInFlight = 0;
      preloadDesired = new Set();
      preloadPaused = false;
    }

    // ========= å¤–é“¾æ‰“å¼€ =========
    function openUrl(url) {
      try { window.open(url, '_blank', 'noopener,noreferrer'); }
      catch (e) { location.href = url; }
    }
    function openShareLibrary() { if (!IS_HOST) return; openUrl('https://docs.qq.com/smartsheet/form/YEXpcygKpwUW%2Ft0jKWP%2FvR7Tzr?tab=t0jKWP'); }
    function openSharedLibrary() { if (!IS_HOST) return; openUrl('https://docs.qq.com/smartsheet/DWUVYcGN5Z0twd1VX?tab=t0jKWP'); }
    function openGithub() { openUrl('https://github.com/Davy-Chendy/anime-master-game'); }

    // ========= Loading æ§åˆ¶ =========
    function setLoadingUI(visible, mainText = '', hintText = '') {
      const loading = document.getElementById('loadingText');
      const main = document.getElementById('loadingMain');
      const hint = document.getElementById('loadingHint');
      if (!loading || !main || !hint) return;

      if (!visible) {
        loading.style.display = 'none';
        hint.style.display = 'none';
        hint.textContent = '';
        main.textContent = '';
        return;
      }

      loading.style.display = 'flex';
      main.textContent = mainText || '';

      if (hintText) {
        hint.style.display = 'block';
        hint.textContent = hintText;
      } else {
        hint.style.display = 'none';
        hint.textContent = '';
      }
    }

    function startLoadingWarnTimer(token) {
      if (loadingWarnTimer) clearTimeout(loadingWarnTimer);
      loadingWarnTimer = setTimeout(() => {
        if (token !== imageLoadToken) return;
        const msg = IS_HOST
          ? 'åŠ è½½è¶…è¿‡ 10 ç§’ï¼šæ­¤å›¾å¯èƒ½é“¾æ¥æœ‰é—®é¢˜ã€‚å¯ç›´æ¥ç‚¹å‡»ã€Œä¸‹ä¸€å¼ å›¾ç‰‡ã€è·³è¿‡æœ¬é¢˜ã€‚'
          : 'åŠ è½½è¶…è¿‡ 10 ç§’';
        const hint = document.getElementById('loadingHint');
        if (hint) {
          hint.style.display = 'block';
          hint.textContent = msg;
        }
      }, 10000);
    }

    // ========= ä¿å­˜é…ç½®å¼¹çª— =========
    function openSaveLoadingModal(mainText = 'æ­£åœ¨åŠ è½½ç¬¬ 1 å¼ å›¾ç‰‡ï¼Œè¯·ç¨å€™â€¦') {
      const modal = document.getElementById('saveLoadingModal');
      const text = document.getElementById('saveLoadingText');
      const btn = document.getElementById('saveLoadingCloseBtn');
      if (text) text.textContent = mainText;
      if (btn) btn.disabled = true;
      if (modal) modal.classList.add('active');
    }
    function closeSaveLoadingModal() {
      const modal = document.getElementById('saveLoadingModal');
      if (modal) modal.classList.remove('active');
    }

    // ========= å¹•å¸ƒï¼ˆHost ç”¨ï¼‰ =========
    function showCurtain() { const c = document.getElementById('curtain'); if (c) c.style.display = 'block'; }
    function hideCurtain() { const c = document.getElementById('curtain'); if (c) c.style.display = 'none'; }

    function resetCellsNoTransition() {
      const overlay = document.getElementById('gridOverlay');
      if (!overlay) return;
      overlay.classList.add('no-transition');
      coverAllCells();
      requestAnimationFrame(() => overlay.classList.remove('no-transition'));
    }

    function openHelp() { if (!IS_HOST) return; document.getElementById('helpModal').classList.add('active'); }
    function closeHelp() { document.getElementById('helpModal').classList.remove('active'); }

    // ========== åŒæ­¥ ==========
    function getGameState() {
      return {
        v: 4,
        ts: Date.now(),
        currentImageIndex,
        currentRound,
        imageUrls,
        players,
        revealedCells: Array.from(revealedCells),
        answerRevealed
      };
    }

    function broadcastState(reason = '') {
      if (!IS_HOST) return;
      channel.postMessage({ type: 'state', reason, state: getGameState() });
    }

    function applyGameState(state) {
      const prevScrollY = (!IS_HOST) ? window.scrollY : 0;

      if (Array.isArray(state.imageUrls)) imageUrls = state.imageUrls;
      if (Array.isArray(state.players)) players = state.players;
      if (typeof state.answerRevealed === 'boolean') answerRevealed = state.answerRevealed;

      const nextImageIndex = Number(state.currentImageIndex || 0);
      const nextRound = Number(state.currentRound || 0);
      const nextRevealed = new Set(Array.isArray(state.revealedCells) ? state.revealedCells : []);

      currentRound = nextRound;
      revealedCells = nextRevealed;

      renderScoreboard();

      const targetUrl = (imageUrls && imageUrls.length > 0) ? imageUrls[nextImageIndex] : '';

      let needLoad;
      if (IS_HOST) {
        needLoad = !!targetUrl && (nextImageIndex !== currentImageIndex);
      } else {
        needLoad = !!targetUrl && (!playerImgReady || playerCurrentUrl !== targetUrl || nextImageIndex !== currentImageIndex);
      }

      currentImageIndex = nextImageIndex;
      updateStatus();

      const ready = (imageUrls.length > 0 && players.length > 0);

      if (ready) {
        if (!IS_HOST) setLoadingUI(true, 'æ­£åœ¨åŒæ­¥é¢˜ç›®...', '');
      } else {
        setLoadingUI(true, 'è¯·å…ˆè®¾ç½®ç©å®¶å’Œå›¾ç‰‡', '');
      }

      if (imageUrls.length > 0) {
        if (IS_HOST) updatePreloadWindow(currentImageIndex); // âœ… Host é¢„åŠ è½½ï¼ˆPlayer ä¸é¢„åŠ è½½ï¼‰

        ensureGrid();

        if (needLoad) {
          if (IS_HOST) {
            showCurtain();
            resetCellsNoTransition();
            loadImage(currentImageIndex, () => {
              ensureGrid();
              renderGridFromState();
              updateStatus();
              updateButtonsByState();
            });
          } else {
            playerImgReady = false;
            drawPlayerCanvasFromState();
            loadImage(currentImageIndex, () => {
              renderGridFromState();
              drawPlayerCanvasFromState();
              updateStatus();
            });
          }
        } else {
          renderGridFromState();
          if (!IS_HOST) {
            ensurePlayerCanvasSized();
            drawPlayerCanvasFromState();
            if (ready) setLoadingUI(false);
          }
          updateButtonsByState();
        }
      } else {
        selectedCells = [];
        isFullImageMode = false;

        ensureGrid(true);
        showCurtain();
        resetCellsNoTransition();
        hideCurtain();

        if (!IS_HOST) {
          playerImgReady = false;
          playerCurrentUrl = '';
          drawPlayerCanvasFromState();
        }

        setLoadingUI(true, 'è¯·å…ˆè®¾ç½®ç©å®¶å’Œå›¾ç‰‡', '');
        updateStatus();
        updateButtonsByState();
      }

      if (!IS_HOST) requestAnimationFrame(() => window.scrollTo(0, prevScrollY));
    }

    channel.onmessage = (ev) => {
      const msg = ev.data;
      if (!msg) return;

      if (msg.type === 'state') {
        if (IS_HOST) return;
        if (!msg.state) return;
        applyGameState(msg.state);
      }

      if (msg.type === 'request_state') {
        if (!IS_HOST) return;
        broadcastState('player_request_state');
      }
    };

    // ========== åˆå§‹åŒ– ==========
    function init() {
      document.getElementById('roleBadge').textContent = IS_HOST ? 'ä¸»æŒäººå±ï¼ˆHOSTï¼‰' : 'ç©å®¶å±ï¼ˆPLAYERï¼‰';

      if (!IS_HOST) {
        document.body.classList.add('player-locked');
        isFullImageMode = false;
      }

      const savedPlayers = localStorage.getItem('animeGamePlayers');
      if (savedPlayers) players = JSON.parse(savedPlayers);

      const savedUrls = localStorage.getItem('animeGameImageUrls');
      if (savedUrls) imageUrls = JSON.parse(savedUrls);

      renderScoreboard();
      ensureGrid();
      updateSelectionCount();
      updateStatus();

      document.getElementById('scoreboardActions').style.display = IS_HOST ? 'flex' : 'none';

      if (IS_HOST) {
        if (imageUrls.length > 0 && players.length > 0) {
          showCurtain();
          loadImage(0, () => {
            document.getElementById('showFullBtn').disabled = false;
            document.getElementById('nextImageBtn').disabled = false;
            document.getElementById('revealAnswerBtn').disabled = false;
            updateButtonsByState();
            broadcastState('init');
          });
          updatePreloadWindow(0); // âœ… Host é¢„åŠ è½½çª—å£
        } else {
          updateButtonsByState();
          setLoadingUI(true, 'è¯·å…ˆè®¾ç½®ç©å®¶å’Œå›¾ç‰‡', '');
        }
      } else {
        setLoadingUI(true, 'ç­‰å¾…ä¸»æŒäººåŒæ­¥é¢˜åº“...', '');
        playerImgReady = false;
        playerCurrentUrl = '';
        ensurePlayerCanvasSized();
        drawPlayerCanvasFromState();
        channel.postMessage({ type: 'request_state', ts: Date.now() });
      }

      if (!IS_HOST) {
        const btn = document.getElementById('openPlayerBtn');
        if (btn) btn.style.display = 'none';
        const helpBtn = document.getElementById('helpBtn');
        if (helpBtn) helpBtn.style.display = 'none';
      }

      window.addEventListener('resize', function () {
        if (!IS_HOST) {
          ensurePlayerCanvasSized();
          drawPlayerCanvasFromState();
        } else {
          syncGridOverlayToTarget();
        }
      });
    }

    function updateButtonsByState() {
      if (!IS_HOST) return;

      const hasReady = (imageUrls.length > 0 && players.length > 0);
      const showFullBtn = document.getElementById('showFullBtn');
      const confirmBtn = document.getElementById('confirmSelectionBtn');
      const nextBtn = document.getElementById('nextImageBtn');
      const revealBtn = document.getElementById('revealAnswerBtn');
      if (!showFullBtn || !confirmBtn || !nextBtn || !revealBtn) return;

      if (answerRevealed) {
        showFullBtn.disabled = true;
        confirmBtn.disabled = true;
        revealBtn.disabled = true;
        nextBtn.disabled = !hasReady;
        return;
      }

      showFullBtn.disabled = !hasReady || isFullImageMode;
      nextBtn.disabled = !hasReady;
      revealBtn.disabled = !hasReady;

      updateSelectionCount();
    }

    function openPlayerScreen() {
      if (!IS_HOST) return;
      const url = new URL(window.location.href);
      url.searchParams.set('role', 'player');
      const w = window.open(url.toString(), 'animeGamePlayer', 'noopener,noreferrer');
      if (!w) {
        alert('æµè§ˆå™¨æ‹¦æˆªäº†å¼¹çª—ã€‚è¯·å…è®¸å¼¹çª—åé‡è¯•ï¼Œæˆ–æ‰‹åŠ¨æ‰“å¼€ï¼š\n' + url.toString());
        return;
      }
      setTimeout(() => { try { w.focus(); } catch (e) { } }, 200);
    }

    function resetAll() {
      if (!IS_HOST) return;
      if (!confirm('ç¡®å®šè¦ä¸€é”®é‡ç½®å—ï¼Ÿè¿™ä¼šæ¸…ç©ºç©å®¶ã€åˆ†æ•°ã€å›¾ç‰‡é…ç½®ï¼Œå¹¶å›åˆ°åˆå§‹ç•Œé¢ã€‚')) return;

      localStorage.removeItem('animeGamePlayers');
      localStorage.removeItem('animeGameImageUrls');

      players = [];
      imageUrls = [];
      currentImageIndex = 0;
      currentRound = 0;
      selectedCells = [];
      revealedCells.clear();
      isFullImageMode = false;
      answerRevealed = false;

      resetPreloadAll(); // âœ… æ¸…ç©ºé¢„åŠ è½½çª—å£çŠ¶æ€

      imageLoadToken++;
      if (loadingWarnTimer) clearTimeout(loadingWarnTimer);

      renderScoreboard();
      ensureGrid(true);
      showCurtain();
      resetCellsNoTransition();
      hideCurtain();

      updateSelectionCount();
      updateStatus();
      updateButtonsByState();

      const img = document.getElementById('gameImage');
      const wrapper = document.getElementById('imageWrapper');
      img.src = '';
      img.style.display = 'none';
      wrapper.style.display = 'none';
      wrapper.style.visibility = 'visible';
      wrapper.style.minHeight = '';

      closeConfig();
      closePlayerSetup();
      closeHelp();
      closeSaveLoadingModal();

      setLoadingUI(true, 'è¯·å…ˆè®¾ç½®ç©å®¶å’Œå›¾ç‰‡', '');

      broadcastState('reset_all');
      alert('å·²é‡ç½®åˆ°åˆå§‹çŠ¶æ€ã€‚');
    }

    function clearAllScores() {
      if (!IS_HOST) return;
      if (players.length === 0) { alert('è¿˜æ²¡æœ‰ç©å®¶ã€‚'); return; }
      if (!confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰ç©å®¶åˆ†æ•°å—ï¼Ÿ')) return;

      players = players.map(p => ({ ...p, score: 0 }));
      localStorage.setItem('animeGamePlayers', JSON.stringify(players));
      renderScoreboard();
      broadcastState('clear_scores');
    }

    function openPlayerSetup() { if (!IS_HOST) return; document.getElementById('playerSetupModal').classList.add('active'); }
    function closePlayerSetup() { document.getElementById('playerSetupModal').classList.remove('active'); }

    function selectPlayerCount(count) {
      if (!IS_HOST) return;
      document.querySelectorAll('.count-btn').forEach(btn => btn.classList.remove('active'));
      event.target.classList.add('active');

      const container = document.getElementById('nameInputs');
      container.innerHTML = '';
      for (let i = 0; i < count; i++) {
        const input = document.createElement('input');
        input.type = 'text';
        input.className = 'player-input';
        input.placeholder = `ç©å®¶ ${i + 1} çš„åå­—`;
        input.value = players[i] ? players[i].name : '';
        container.appendChild(input);
      }
      document.getElementById('playerNamesInput').classList.add('active');
    }

    function savePlayerSetup() {
      if (!IS_HOST) return;
      const inputs = document.querySelectorAll('#nameInputs .player-input');
      if (inputs.length === 0) { alert('è¯·å…ˆé€‰æ‹©ç©å®¶äººæ•°ï¼'); return; }

      const newPlayers = [];
      let hasEmpty = false;

      inputs.forEach((input, index) => {
        const name = input.value.trim();
        if (!name) { hasEmpty = true; return; }
        newPlayers.push({ name, score: players[index] ? players[index].score : 0 });
      });

      if (hasEmpty) { alert('è¯·å¡«å†™æ‰€æœ‰ç©å®¶çš„åå­—ï¼'); return; }

      players = newPlayers;
      localStorage.setItem('animeGamePlayers', JSON.stringify(players));
      renderScoreboard();
      closePlayerSetup();

      if (imageUrls.length > 0) {
        document.getElementById('showFullBtn').disabled = false;
        document.getElementById('nextImageBtn').disabled = false;
        document.getElementById('revealAnswerBtn').disabled = false;
      }

      updateButtonsByState();
      broadcastState('save_players');
      alert(`æˆåŠŸè®¾ç½® ${players.length} ä½ç©å®¶ï¼`);

      if (imageUrls.length > 0 && players.length > 0) {
        setLoadingUI(false);
        if (IS_HOST) updatePreloadWindow(currentImageIndex);
      }
    }

    function renderScoreboard() {
      const container = document.getElementById('playersGrid');
      container.innerHTML = '';

      if (players.length === 0) {
        document.getElementById('scoreboard').style.display = 'none';
        return;
      }

      document.getElementById('scoreboard').style.display = 'block';

      players.forEach((player, index) => {
        const card = document.createElement('div');
        card.className = 'player-card';
        card.innerHTML = `
          <div class="player-info">
            <div class="player-name">${escapeHtml(player.name)}</div>
            <div class="player-score">${player.score} åˆ†</div>
          </div>
          <div class="score-buttons">
            <button class="score-btn plus" onclick="addScore(${index}, 1)">+</button>
            <button class="score-btn minus" onclick="addScore(${index}, -1)">âˆ’</button>
          </div>
        `;
        container.appendChild(card);
      });
    }

    function addScore(playerIndex, delta) {
      if (!IS_HOST) return;
      players[playerIndex].score += delta;
      if (players[playerIndex].score < 0) players[playerIndex].score = 0;
      localStorage.setItem('animeGamePlayers', JSON.stringify(players));
      renderScoreboard();
      broadcastState('score_change');
    }

    function openConfig() {
      if (!IS_HOST) return;
      document.getElementById('configModal').classList.add('active');
      document.getElementById('imageUrlsInput').value = imageUrls.join('\n');

      const select = document.getElementById('presetSelect');
      if (select) select.classList.add('preset-hidden');
    }

    function closeConfig() { document.getElementById('configModal').classList.remove('active'); }

    async function saveConfig() {
      if (!IS_HOST) return;
      const input = document.getElementById('imageUrlsInput').value;
      const urls = input.split('\n').map(u => u.trim()).filter(u => u.length > 0);

      if (urls.length === 0) { alert('è¯·è‡³å°‘è¾“å…¥ä¸€ä¸ªå›¾ç‰‡é“¾æ¥ï¼'); return; }

      imageUrls = urls;
      localStorage.setItem('animeGameImageUrls', JSON.stringify(imageUrls));

      answerRevealed = false;
      resetProgressForNewImage(0);

      // âœ… æ–°é¢˜åº“ï¼šé‡ç½®é¢„åŠ è½½çª—å£ï¼ˆé¿å…æ—§ cache å¹²æ‰°ï¼‰
      resetPreloadAll();

      updateStatus();

      showCurtain();
      resetCellsNoTransition();

      openSaveLoadingModal('æ­£åœ¨åŠ è½½ç¬¬ 1 å¼ å›¾ç‰‡ï¼ˆå½“å‰å›¾ä¼˜å…ˆï¼‰ï¼Œå¹¶å‡†å¤‡é¢„åŠ è½½æœªæ¥å‡ å¼ â€¦');
      setLoadingUI(true, 'æ­£åœ¨åŠ è½½å›¾ç‰‡...', 'æ­£åœ¨åŠ è½½ç¬¬ 1 å¼ ï¼ˆå½“å‰å›¾ä¼˜å…ˆï¼‰ï¼Œç¨å€™å°†é¢„åŠ è½½æœªæ¥å‡ å¼ â€¦');

      await new Promise((resolve) => { loadImage(0, () => resolve()); });

      // âœ… å½“å‰å›¾ç»“æŸåå†å¯åŠ¨çª—å£é¢„åŠ è½½ï¼ˆHostï¼‰
      updatePreloadWindow(0);

      closeSaveLoadingModal();

      ensureGrid(true);
      renderGridFromState();
      updateStatus();
      updateButtonsByState();

      if (players.length > 0 && imageUrls.length > 0) {
        document.getElementById('showFullBtn').disabled = false;
        document.getElementById('nextImageBtn').disabled = false;
        document.getElementById('revealAnswerBtn').disabled = false;
      }

      document.getElementById('confirmSelectionBtn').disabled = true;
      updateSelectionCount();

      broadcastState('save_config');
      closeConfig();

      alert(`åŠ è½½å®Œæˆï¼å·²è½½å…¥ ${imageUrls.length} å¼ å›¾ç‰‡ã€‚`);
    }

    function resetProgressForNewImage(index) {
      currentImageIndex = index;
      currentRound = 0;
      selectedCells = [];
      revealedCells.clear();
      isFullImageMode = false;
    }

    function loadImage(index, onDone) {
      if (index < 0 || index >= imageUrls.length) {
        if (IS_HOST) alert('å›¾ç‰‡ç´¢å¼•è¶…å‡ºèŒƒå›´ï¼');
        return;
      }

      const token = ++imageLoadToken;
      if (loadingWarnTimer) clearTimeout(loadingWarnTimer);

      setLoadingUI(true, 'åŠ è½½ä¸­...', '');
      startLoadingWarnTimer(token);

      const url = imageUrls[index];

      if (IS_HOST) {
        // âœ… å½“å‰å›¾ç»å¯¹ä¼˜å…ˆï¼šåŠ è½½å½“å‰å›¾æœŸé—´æš‚åœå¯åŠ¨é¢„åŠ è½½
        setPreloadPaused(true);
        // âœ… æ›´æ–°çª—å£ç›®æ ‡ï¼ˆé˜Ÿåˆ—å‡†å¤‡å¥½ï¼Œä½† paused ä¸ä¼šå¯åŠ¨é¢„åŠ è½½è¯·æ±‚ï¼‰
        updatePreloadWindow(index);

        const img = document.getElementById('gameImage');
        const wrapper = document.getElementById('imageWrapper');

        const prevH = wrapper.offsetHeight || img.offsetHeight || 0;
        wrapper.style.display = 'inline-block';
        wrapper.style.visibility = 'hidden';
        if (prevH > 0) wrapper.style.minHeight = prevH + 'px';

        showCurtain();
        ensureGrid();
        resetCellsNoTransition();

        img.style.display = 'none';

        img.onload = function () {
          if (token !== imageLoadToken) return;
          if (loadingWarnTimer) clearTimeout(loadingWarnTimer);

          wrapper.style.display = 'inline-block';
          wrapper.style.visibility = 'visible';
          wrapper.style.minHeight = '';

          img.style.display = 'block';
          syncGridOverlayToTarget();

          setLoadingUI(false);

          if (typeof onDone === 'function') onDone();

          hideCurtain();

          // âœ… å½“å‰å›¾åŠ è½½å®Œæˆï¼šæ¢å¤é¢„åŠ è½½ï¼Œå¹¶è®©çª—å£è·Ÿéšå½“å‰å›¾
          setPreloadPaused(false);
          updatePreloadWindow(currentImageIndex);
        };

        img.onerror = function () {
          if (token !== imageLoadToken) return;
          if (loadingWarnTimer) clearTimeout(loadingWarnTimer);

          const msg = 'å›¾ç‰‡åŠ è½½å¤±è´¥ï¼šè¯·æ£€æŸ¥é“¾æ¥ï¼Œæˆ–ç›´æ¥ç‚¹å‡»ã€Œä¸‹ä¸€å¼ å›¾ç‰‡ã€è·³è¿‡æœ¬é¢˜ã€‚';
          setLoadingUI(true, 'å›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥é“¾æ¥', msg);

          wrapper.style.visibility = 'visible';
          wrapper.style.minHeight = '';
          hideCurtain();

          if (typeof onDone === 'function') onDone();

          // âœ… å¤±è´¥ä¹Ÿæ¢å¤é¢„åŠ è½½ï¼ˆä»¥å…å¡æ­»åœ¨ pausedï¼‰
          setPreloadPaused(false);
          updatePreloadWindow(currentImageIndex);
        };

        // å¯é€‰ï¼šé™ä½ Referer å¯¼è‡´çš„é˜²ç›—é“¾æ¦‚ç‡ï¼ˆæˆæœ¬ä½ï¼‰
        try { img.referrerPolicy = 'no-referrer'; } catch (e) {}

        img.src = url;
        return;
      }

      // Player: ç¦»å±åŠ è½½åˆ° playerImgï¼Œç„¶å canvas ç™½åå•ç»˜åˆ¶ï¼ˆâœ… ä¸é¢„åŠ è½½ï¼‰
      playerImgReady = false;
      drawPlayerCanvasFromState();

      try { playerImg.referrerPolicy = 'no-referrer'; } catch (e) {}

      playerImg.onload = function () {
        if (token !== imageLoadToken) return;
        if (loadingWarnTimer) clearTimeout(loadingWarnTimer);

        playerImgReady = true;
        playerCurrentUrl = url;

        ensurePlayerCanvasSized();
        setLoadingUI(false);

        drawPlayerCanvasFromState();

        if (typeof onDone === 'function') onDone();
      };

      playerImg.onerror = function () {
        if (token !== imageLoadToken) return;
        if (loadingWarnTimer) clearTimeout(loadingWarnTimer);

        playerImgReady = false;
        playerCurrentUrl = '';

        setLoadingUI(true, 'å›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥é“¾æ¥', 'å›¾ç‰‡åŠ è½½å¤±è´¥');
        drawPlayerCanvasFromState();

        if (typeof onDone === 'function') onDone();
      };

      playerImg.src = url;
    }

    function ensureGrid(forceRecreate = false) {
      const overlay = document.getElementById('gridOverlay');
      if (!overlay) return;
      if (forceRecreate || overlay.children.length !== TOTAL_CELLS) createGrid();
      syncGridOverlayToTarget();
    }

    function createGrid() {
      const overlay = document.getElementById('gridOverlay');
      overlay.innerHTML = '';
      for (let i = 0; i < TOTAL_CELLS; i++) {
        const cell = document.createElement('div');
        cell.className = 'grid-cell covered';
        cell.dataset.index = i;
        cell.onclick = () => selectCell(i);
        overlay.appendChild(cell);
      }
    }

    function coverAllCells() {
      const cells = document.querySelectorAll('.grid-cell');
      cells.forEach(cell => {
        cell.classList.remove('selectable', 'selected', 'revealed', 'revealed-hint');
        cell.classList.add('covered');
      });
    }

    function showFullImage() {
      if (!IS_HOST) return;
      if (answerRevealed) return;

      selectedCells = [];
      isFullImageMode = true;

      document.getElementById('showFullBtn').disabled = true;

      updateSelectionCount();
      renderGridFromState();
      updateButtonsByState();
    }

    function selectCell(index) {
      if (!IS_HOST) return;
      if (!isFullImageMode) return;
      if (answerRevealed) return;
      if (revealedCells.has(index)) return;

      const cell = document.querySelectorAll('.grid-cell')[index];
      if (selectedCells.includes(index)) {
        selectedCells = selectedCells.filter(i => i !== index);
        cell.classList.remove('selected');
      } else {
        selectedCells.push(index);
        cell.classList.add('selected');
      }

      updateSelectionCount();
    }

    function updateSelectionCount() {
      const el = document.getElementById('selectionCount');
      if (el) el.textContent = `å·²é€‰æ‹©: ${selectedCells.length} ä¸ªæ–¹å—`;

      const confirmBtn = document.getElementById('confirmSelectionBtn');
      if (confirmBtn) {
        const canConfirm = IS_HOST && isFullImageMode && !answerRevealed && (selectedCells.length > 0);
        confirmBtn.disabled = !canConfirm;
      }
    }

    function confirmSelection() {
      if (!IS_HOST) return;
      if (!isFullImageMode) return;
      if (answerRevealed) return;
      if (selectedCells.length <= 0) return;

      selectedCells.forEach(index => revealedCells.add(index));

      currentRound++;
      selectedCells = [];
      isFullImageMode = false;

      document.getElementById('confirmSelectionBtn').disabled = true;
      document.getElementById('showFullBtn').disabled = false;

      updateSelectionCount();
      renderGridFromState();
      updateStatus();
      updateButtonsByState();
      broadcastState('confirm_selection');
    }

    function revealAnswerToAll() {
      if (!IS_HOST) return;
      if (imageUrls.length === 0) return;

      answerRevealed = true;
      isFullImageMode = false;
      selectedCells = [];

      renderGridFromState();
      updateButtonsByState();
      broadcastState('reveal_answer');
    }

    function nextImage() {
      if (!IS_HOST) return;

      if (!answerRevealed) {
        if (!confirm('ç¡®å®šè¦è¿›å…¥ä¸‹ä¸€å¼ å›¾ç‰‡å—ï¼Ÿå½“å‰è¿›åº¦å°†é‡ç½®ã€‚')) return;
      }

      const wasLast = (imageUrls.length > 0 && currentImageIndex === imageUrls.length - 1);

      let next = currentImageIndex + 1;
      if (next >= imageUrls.length) next = 0;

      if (wasLast && imageUrls.length > 0) {
        alert('âœ… å·²å®Œæˆä¸€è½®é¢˜åº“ï¼å³å°†å›åˆ°ç¬¬ 1 å¼ ç»§ç»­ã€‚');
      }

      resetProgressForNewImage(next);
      answerRevealed = false;

      updateStatus();
      broadcastState('next_image_start');

      if (IS_HOST) updatePreloadWindow(currentImageIndex);

      ensureGrid();
      showCurtain();
      resetCellsNoTransition();

      loadImage(currentImageIndex, () => {
        ensureGrid(true);
        renderGridFromState();

        document.getElementById('showFullBtn').disabled = false;
        document.getElementById('confirmSelectionBtn').disabled = true;

        updateStatus();
        updateSelectionCount();
        updateButtonsByState();
        broadcastState('next_image_done');
      });
    }

    function renderGridFromState() {
      const cells = document.querySelectorAll('.grid-cell');
      if (!cells || cells.length === 0) return;

      const inHostSelectMode = (IS_HOST && isFullImageMode);

      if (answerRevealed) {
        cells.forEach(cell => {
          cell.classList.remove('selectable', 'selected', 'revealed', 'revealed-hint', 'covered');
        });
        if (!IS_HOST) drawPlayerCanvasFromState();
        return;
      }

      cells.forEach((cell, index) => {
        cell.classList.remove('selectable', 'selected', 'revealed', 'revealed-hint');

        if (inHostSelectMode) {
          cell.classList.remove('covered');
          cell.classList.add('selectable');

          if (selectedCells.includes(index)) cell.classList.add('selected');
          if (revealedCells.has(index)) cell.classList.add('revealed-hint');
        }

        if (revealedCells.has(index)) {
          cell.classList.remove('covered');
          cell.classList.add('revealed');
          return;
        }

        if (!inHostSelectMode) cell.classList.add('covered');
      });

      if (!IS_HOST) drawPlayerCanvasFromState();
    }

    function updateStatus() {
      document.getElementById('currentImage').textContent = imageUrls.length ? (currentImageIndex + 1) : 0;
      document.getElementById('totalImages').textContent = imageUrls.length;
      document.getElementById('currentRound').textContent = currentRound;
      document.getElementById('revealedCount').textContent = revealedCells.size;

      if (IS_HOST) {
        const ready = (imageUrls.length > 0 && players.length > 0);
        document.getElementById('revealAnswerBtn').disabled = !ready || answerRevealed;
      }
    }

    function escapeHtml(str) {
      return String(str)
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#039;');
    }

    window.onload = init;
  </script>
</body>

</html>
